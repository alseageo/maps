/* eslint-disable */
// DO NOT MODIFY
// THIS FILE IS AUTOGENERATED

import FillLayer from '../components/FillLayer'
import LineLayer from '../components/LineLayer'
import SymbolLayer from '../components/SymbolLayer'
import CircleLayer from '../components/CircleLayer'
import FillExtrusionLayer from '../components/FillExtrusionLayer'
import RasterLayer from '../components/RasterLayer'
import BackgroundLayer from '../components/BackgroundLayer'
import LightLayer from '../components/LightLayer'

function stripUndefined(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key]
    }
  }
  return obj
}

export default function MapboxLayerComponentFromStyleJSON({ layer, aboveLayerID, belowLayerID, layerIndex }) {
  // Flatten layout and paint property objects into parent
  layer.layout = layer.layout || {}
  layer.paint = layer.paint || {}
  const { layout, paint, ...otherProperties } = layer
  const layerProps = { ...layout, ...paint, ...otherProperties }

  const commonProps = stripUndefined({
    key: layerProps.id,
    id: layerProps.id,
    sourceID: layerProps.source,
    minZoomLevel: layerProps.minzoom,
    maxZoomLevel: layerProps.maxzoom,
    aboveLayerID: aboveLayerID,
    belowLayerID: belowLayerID,
    layerIndex: layerIndex,
    filter: layerProps.filter,
    sourceLayerID: layerProps['source-layer'],
  });

  if (layer.type === 'fill') {
    const style = stripUndefined({
      visibility: layerProps['visibility'],
      fillAntialias: layerProps['fill-antialias'],
      fillOpacity: layerProps['fill-opacity'],
      fillColor: layerProps['fill-color'],
      fillOutlineColor: layerProps['fill-outline-color'],
      fillTranslate: layerProps['fill-translate'],
      fillTranslateAnchor: layerProps['fill-translate-anchor'],
      fillPattern: layerProps['fill-pattern'],
    })
    return (
      <FillLayer
        {...commonProps}
        style={style}
      />
    )
  }
  if (layer.type === 'line') {
    const style = stripUndefined({
      lineCap: layerProps['line-cap'],
      lineJoin: layerProps['line-join'],
      lineMiterLimit: layerProps['line-miter-limit'],
      lineRoundLimit: layerProps['line-round-limit'],
      visibility: layerProps['visibility'],
      lineOpacity: layerProps['line-opacity'],
      lineColor: layerProps['line-color'],
      lineTranslate: layerProps['line-translate'],
      lineTranslateAnchor: layerProps['line-translate-anchor'],
      lineWidth: layerProps['line-width'],
      lineGapWidth: layerProps['line-gap-width'],
      lineOffset: layerProps['line-offset'],
      lineBlur: layerProps['line-blur'],
      lineDasharray: layerProps['line-dasharray'],
      linePattern: layerProps['line-pattern'],
      lineGradient: layerProps['line-gradient'],
    })
    return (
      <LineLayer
        {...commonProps}
        style={style}
      />
    )
  }
  if (layer.type === 'symbol') {
    const style = stripUndefined({
      symbolPlacement: layerProps['symbol-placement'],
      symbolSpacing: layerProps['symbol-spacing'],
      symbolAvoidEdges: layerProps['symbol-avoid-edges'],
      symbolZOrder: layerProps['symbol-z-order'],
      iconAllowOverlap: layerProps['icon-allow-overlap'],
      iconIgnorePlacement: layerProps['icon-ignore-placement'],
      iconOptional: layerProps['icon-optional'],
      iconRotationAlignment: layerProps['icon-rotation-alignment'],
      iconSize: layerProps['icon-size'],
      iconTextFit: layerProps['icon-text-fit'],
      iconTextFitPadding: layerProps['icon-text-fit-padding'],
      iconImage: layerProps['icon-image'],
      iconRotate: layerProps['icon-rotate'],
      iconPadding: layerProps['icon-padding'],
      iconKeepUpright: layerProps['icon-keep-upright'],
      iconOffset: layerProps['icon-offset'],
      iconAnchor: layerProps['icon-anchor'],
      iconPitchAlignment: layerProps['icon-pitch-alignment'],
      textPitchAlignment: layerProps['text-pitch-alignment'],
      textRotationAlignment: layerProps['text-rotation-alignment'],
      textField: layerProps['text-field'],
      textFont: layerProps['text-font'],
      textSize: layerProps['text-size'],
      textMaxWidth: layerProps['text-max-width'],
      textLineHeight: layerProps['text-line-height'],
      textLetterSpacing: layerProps['text-letter-spacing'],
      textJustify: layerProps['text-justify'],
      textAnchor: layerProps['text-anchor'],
      textMaxAngle: layerProps['text-max-angle'],
      textRotate: layerProps['text-rotate'],
      textPadding: layerProps['text-padding'],
      textKeepUpright: layerProps['text-keep-upright'],
      textTransform: layerProps['text-transform'],
      textOffset: layerProps['text-offset'],
      textAllowOverlap: layerProps['text-allow-overlap'],
      textIgnorePlacement: layerProps['text-ignore-placement'],
      textOptional: layerProps['text-optional'],
      visibility: layerProps['visibility'],
      iconOpacity: layerProps['icon-opacity'],
      iconColor: layerProps['icon-color'],
      iconHaloColor: layerProps['icon-halo-color'],
      iconHaloWidth: layerProps['icon-halo-width'],
      iconHaloBlur: layerProps['icon-halo-blur'],
      iconTranslate: layerProps['icon-translate'],
      iconTranslateAnchor: layerProps['icon-translate-anchor'],
      textOpacity: layerProps['text-opacity'],
      textColor: layerProps['text-color'],
      textHaloColor: layerProps['text-halo-color'],
      textHaloWidth: layerProps['text-halo-width'],
      textHaloBlur: layerProps['text-halo-blur'],
      textTranslate: layerProps['text-translate'],
      textTranslateAnchor: layerProps['text-translate-anchor'],
    })
    return (
      <SymbolLayer
        {...commonProps}
        style={style}
      />
    )
  }
  if (layer.type === 'circle') {
    const style = stripUndefined({
      visibility: layerProps['visibility'],
      circleRadius: layerProps['circle-radius'],
      circleColor: layerProps['circle-color'],
      circleBlur: layerProps['circle-blur'],
      circleOpacity: layerProps['circle-opacity'],
      circleTranslate: layerProps['circle-translate'],
      circleTranslateAnchor: layerProps['circle-translate-anchor'],
      circlePitchScale: layerProps['circle-pitch-scale'],
      circlePitchAlignment: layerProps['circle-pitch-alignment'],
      circleStrokeWidth: layerProps['circle-stroke-width'],
      circleStrokeColor: layerProps['circle-stroke-color'],
      circleStrokeOpacity: layerProps['circle-stroke-opacity'],
    })
    return (
      <CircleLayer
        {...commonProps}
        style={style}
      />
    )
  }
  if (layer.type === 'fill-extrusion') {
    const style = stripUndefined({
      visibility: layerProps['visibility'],
      fillExtrusionOpacity: layerProps['fill-extrusion-opacity'],
      fillExtrusionColor: layerProps['fill-extrusion-color'],
      fillExtrusionTranslate: layerProps['fill-extrusion-translate'],
      fillExtrusionTranslateAnchor: layerProps['fill-extrusion-translate-anchor'],
      fillExtrusionPattern: layerProps['fill-extrusion-pattern'],
      fillExtrusionHeight: layerProps['fill-extrusion-height'],
      fillExtrusionBase: layerProps['fill-extrusion-base'],
    })
    return (
      <FillExtrusionLayer
        {...commonProps}
        style={style}
      />
    )
  }
  if (layer.type === 'raster') {
    const style = stripUndefined({
      visibility: layerProps['visibility'],
      rasterOpacity: layerProps['raster-opacity'],
      rasterHueRotate: layerProps['raster-hue-rotate'],
      rasterBrightnessMin: layerProps['raster-brightness-min'],
      rasterBrightnessMax: layerProps['raster-brightness-max'],
      rasterSaturation: layerProps['raster-saturation'],
      rasterContrast: layerProps['raster-contrast'],
      rasterResampling: layerProps['raster-resampling'],
      rasterFadeDuration: layerProps['raster-fade-duration'],
    })
    return (
      <RasterLayer
        {...commonProps}
        style={style}
      />
    )
  }
  if (layer.type === 'background') {
    const style = stripUndefined({
      visibility: layerProps['visibility'],
      backgroundColor: layerProps['background-color'],
      backgroundPattern: layerProps['background-pattern'],
      backgroundOpacity: layerProps['background-opacity'],
    })
    return (
      <BackgroundLayer
        {...commonProps}
        style={style}
      />
    )
  }
  if (layer.type === 'light') {
    const style = stripUndefined({
      anchor: layerProps['anchor'],
      position: layerProps['position'],
      color: layerProps['color'],
      intensity: layerProps['intensity'],
    })
    return (
      <LightLayer
        {...commonProps}
        style={style}
      />
    )
  }
  return null;
}